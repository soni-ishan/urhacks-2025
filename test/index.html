<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floor Plan Graph Editor</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Style for the container that holds the background image */
        #canvas-container {
            position: relative;
            /* The background image is applied here */
            background-image: url('blueprint.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* This will be sized by JS to match the image aspect ratio */
            margin: auto;
            border: 2px solid #ccc;
            border-radius: 8px;
            overflow: hidden;
            touch-action: none; /* Disable panning/zooming on mobile */
        }
        /* The canvas is a transparent layer on top */
        #graph-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        /* Style for the active button */
        .btn-active {
            background-color: #1d4ed8; /* blue-700 */
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">

    <div class="max-w-6xl mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-2xl font-bold text-center text-gray-800 mb-4">Floor Plan Graph Editor</h1>

        <!-- Control Panel -->
        <div class="flex flex-wrap justify-center gap-3 mb-4 p-4 bg-gray-50 rounded-lg">
            <button id="add-node-btn" class="btn-active px-4 py-2 bg-blue-600 text-white rounded-md font-medium transition-all hover:bg-blue-700">
                Add Node
            </button>
            <button id="add-edge-btn" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-md font-medium transition-all hover:bg-gray-400">
                Add Edge
            </button>
            <button id="remove-btn" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-md font-medium transition-all hover:bg-gray-400">
                Remove Item
            </button>
            <button id="find-path-btn" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-md font-medium transition-all hover:bg-gray-400">
                Find Path
            </button>
            <button id="clear-btn" class="px-4 py-2 bg-red-500 text-white rounded-md font-medium transition-all hover:bg-red-600">
                Clear Graph
            </button>
        </div>

        <!-- Instructions -->
        <div id="instructions" class="text-center text-gray-600 mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
            <p id="instruction-text"><b>Mode:</b> Add Node. Click on the floor plan to add a node.</p>
        </div>

        <!-- Canvas Container -->
        <!-- The background image and canvas will be loaded inside here -->
        <div id="canvas-container" class="w-full max-w-5xl mx-auto">
            <canvas id="graph-canvas"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('canvas-container');

            // --- Buttons and UI ---
            const addNodeBtn = document.getElementById('add-node-btn');
            const addEdgeBtn = document.getElementById('add-edge-btn');
            const removeBtn = document.getElementById('remove-btn');
            const findPathBtn = document.getElementById('find-path-btn');
            const clearBtn = document.getElementById('clear-btn');
            const instructionText = document.getElementById('instruction-text');

            // --- App State ---
            let mode = 'addNode'; // 'addNode', 'addEdge', 'remove', or 'findPath'
            let nodes = []; // Array of { id, x, y }
            let edges = []; // Array of { from, to } (using node IDs)
            let currentNodeId = 0;
            let edgeStartNode = null;
            let pathStartNode = null; // For shortest path finding
            let shortestPath = []; // Array of points {x, y} to draw
            const NODE_RADIUS = 8; // Visual size of the node
            const HIT_RADIUS = 12; // Clickable area of the node
            const EDGE_HIT_RADIUS = 5; // Clickable area for an edge

            const backgroundImage = new Image();
            // *** IMPORTANT ***
            // This assumes 'blueprint.png' is in the same folder as this HTML file.
            backgroundImage.src = 'blueprint.png';

            // --- Initialization ---
            backgroundImage.onload = () => {
                // Set the container's aspect ratio to match the image
                container.style.aspectRatio = `${backgroundImage.naturalWidth} / ${backgroundImage.naturalHeight}`;
                // Perform an initial resize to set up the canvas
                resizeCanvas();
            };

            // --- Event Listeners ---
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('click', handleCanvasClick);
            addNodeBtn.addEventListener('click', () => setMode('addNode'));
            addEdgeBtn.addEventListener('click', () => setMode('addEdge'));
            removeBtn.addEventListener('click', () => setMode('remove'));
            findPathBtn.addEventListener('click', () => setMode('findPath'));
            clearBtn.addEventListener('click', clearGraph);


            // --- Core Functions ---

            /**
             * Sets the canvas bitmap dimensions to match its container's display size.
             * This is crucial for correct coordinate mapping and sharp rendering.
             */
            function resizeCanvas() {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                // Redraw everything after resizing
                draw();
            }

            /**
             * Sets the current interaction mode ('addNode' or 'addEdge')
             */
            function setMode(newMode) {
                // Clear path state if switching away from findPath mode
                if (mode === 'findPath' && newMode !== 'findPath') {
                    pathStartNode = null;
                    shortestPath = [];
                }
                
                mode = newMode;
                edgeStartNode = null; // Reset edge drawing

                // Update button styles
                addNodeBtn.classList.toggle('btn-active', mode === 'addNode');
                addNodeBtn.classList.toggle('bg-gray-300', mode !== 'addNode');
                addEdgeBtn.classList.toggle('btn-active', mode === 'addEdge');
                addEdgeBtn.classList.toggle('bg-gray-300', mode !== 'addEdge');
                removeBtn.classList.toggle('btn-active', mode === 'remove');
                removeBtn.classList.toggle('bg-gray-300', mode !== 'remove');
                findPathBtn.classList.toggle('btn-active', mode === 'findPath');
                findPathBtn.classList.toggle('bg-gray-300', mode !== 'findPath');


                // Update instructions
                if (mode === 'addNode') {
                    instructionText.innerHTML = '<b>Mode:</b> Add Node. Click on the floor plan to add a node.';
                } else if (mode === 'addEdge') {
                    instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                } else if (mode === 'remove') {
                    instructionText.innerHTML = '<b>Mode:</b> Remove. Click on a node or edge to delete it.';
                } else if (mode === 'findPath') {
                    pathStartNode = null;
                    shortestPath = [];
                    instructionText.innerHTML = '<b>Mode:</b> Find Path. Click the start node.';
                }
                draw(); // Redraw to clear any highlights
            }

            /**
             * Handles all click events on the canvas
             */
            function handleCanvasClick(event) {
                // Get click coordinates relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;

                if (mode === 'addNode') {
                    addNode(x, y);
                } else if (mode === 'addEdge') {
                    handleAddEdge(x, y);
                } else if (mode === 'remove') {
                    handleRemove(x, y);
                } else if (mode === 'findPath') {
                    handleFindPath(x, y);
                }

                draw(); // Redraw the canvas after every action
            }

            /**
             * Adds a new node at the specified coordinates
             */
            function addNode(x, y) {
                const newNode = { id: currentNodeId++, x, y };
                nodes.push(newNode);
            }

            /**
             * Manages the two-click process of adding an edge
             */
            function handleAddEdge(x, y) {
                const clickedNode = getNodeAt(x, y);

                if (!edgeStartNode) {
                    // This is the first click. It MUST be a node.
                    if (clickedNode) {
                        edgeStartNode = clickedNode;
                        instructionText.innerHTML = `<b>Mode:</b> Add Edge. Start node ${edgeStartNode.id} selected. Click a second node or an edge to connect.`;
                    }
                    return; // Wait for the second click
                }

                // If we are here, edgeStartNode is set. This is the second click.
                
                // Case 1: Second click is on a Node
                if (clickedNode) {
                    if (edgeStartNode.id !== clickedNode.id) {
                        addEdge(edgeStartNode, clickedNode);
                    }
                    // Reset for the next edge
                    edgeStartNode = null;
                    instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                    return; // Action complete
                } 
                
                // Case 2: Second click is NOT on a Node. Check if it's on an Edge.
                const clickedEdge = getEdgeAt(x, y);
                if (clickedEdge) {
                    // User clicked a start node, and now an edge.
                    // This is the new "shortest distance" feature.

                    const nodeFrom = nodes.find(n => n.id === clickedEdge.from);
                    const nodeTo = nodes.find(n => n.id === clickedEdge.to);
                    
                    if (!nodeFrom || !nodeTo) {
                         // This case should be impossible if edge exists, but good to check
                        edgeStartNode = null;
                        instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                        return; // Reset
                    }

                    // Check if the start node is one of the edge's endpoints. If so, do nothing.
                    if (edgeStartNode.id === nodeFrom.id || edgeStartNode.id === nodeTo.id) {
                        edgeStartNode = null;
                        instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                        return; // Clicked node and an edge it's already part of.
                    }

                    // 1. Find the closest point P on the edge segment (nodeFrom, nodeTo) to edgeStartNode
                    const closestPoint = getClosestPointOnSegment(edgeStartNode, nodeFrom, nodeTo);

                    // 2. Create a new node (Node D) at this closest point
                    const newNode = { id: currentNodeId++, x: closestPoint.x, y: closestPoint.y };
                    nodes.push(newNode); // Using push directly

                    // 3. Remove the original edge (B-C)
                    removeEdge(clickedEdge); // This function already exists

                    // 4. Add new edges: (A-D), (B-D), (C-D)
                    addEdge(edgeStartNode, newNode);
                    addEdge(nodeFrom, newNode);
                    addEdge(nodeTo, newNode);
                    
                    // 5. Reset
                    edgeStartNode = null;
                    instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                    return; // Action complete
                }

                // Case 3: Second click is on empty space.
                // Cancel edge drawing
                edgeStartNode = null;
                instructionText.innerHTML = '<b>Mode:</b> Add Edge. Click a start node, then an end node or an edge.';
                // No return here, let draw() be called at the end of handleCanvasClick
            }

            /**
             * Adds an edge to the state, preventing duplicates
             */
            function addEdge(node1, node2) {
                // Check if this edge already exists (in either direction)
                const exists = edges.some(edge =>
                    (edge.from === node1.id && edge.to === node2.id) ||
                    (edge.from === node2.id && edge.to === node1.id)
                );

                if (!exists) {
                    edges.push({ from: node1.id, to: node2.id });
                }
            }

            /**
             * Finds and returns the node at a given (x, y) coordinate, if any
             */
            function getNodeAt(x, y) {
                // Search in reverse so we find the topmost node first
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                    if (dist < HIT_RADIUS) {
                        return node;
                    }
                }
                return null;
            }

            /**
             * Calculates the closest point on a line segment (p1, p2) to a point (p).
             * @param {object} p - The point {x, y}
             * @param {object} p1 - The start of the segment {x, y}
             * @param {object} p2 - The end of the segment {x, y}
             * @returns {object} The closest point {x, y} on the segment
             */
            function getClosestPointOnSegment(p, p1, p2) {
                const px = p.x, py = p.y;
                const x1 = p1.x, y1 = p1.y;
                const x2 = p2.x, y2 = p2.y;

                const dx = x2 - x1;
                const dy = y2 - y1;
                const lenSq = dx * dx + dy * dy;

                if (lenSq === 0) {
                    // Segment is a point
                    return { x: x1, y: y1 };
                }

                // t is the projection parameter of P(x,y) onto the line
                const t = ((px - x1) * dx + (py - y1) * dy) / lenSq;

                if (t < 0) {
                    // Closest point is p1
                    return { x: x1, y: y1 };
                } else if (t > 1) {
                    // Closest point is p2
                    return { x: x2, y: y2 };
                } else {
                    // Closest point is on the segment
                    return {
                        x: x1 + t * dx,
                        y: y1 + t * dy
                    };
                }
            }

            /**
             * Finds and returns the edge at a given (x, y) coordinate, if any
             */
            function getEdgeAt(x, y) {
                for (const edge of edges) {
                    const nodeFrom = nodes.find(n => n.id === edge.from);
                    const nodeTo = nodes.find(n => n.id === edge.to);

                    if (!nodeFrom || !nodeTo) continue;

                    const clickPoint = { x, y };
                    const edgeStart = { x: nodeFrom.x, y: nodeFrom.y };
                    const edgeEnd = { x: nodeTo.x, y: nodeTo.y };

                    const closestPoint = getClosestPointOnSegment(clickPoint, edgeStart, edgeEnd);

                    // Calculate distance from click (px, py) to the closest point on the segment
                    const dist = Math.sqrt((x - closestPoint.x) ** 2 + (y - closestPoint.y) ** 2);

                    if (dist < EDGE_HIT_RADIUS) {
                        return edge;
                    }
                }
                return null;
            }

            /**
             * Handles a click in 'remove' mode
             */
            function handleRemove(x, y) {
                // Prioritize removing nodes over edges
                const clickedNode = getNodeAt(x, y);
                if (clickedNode) {
                    removeNode(clickedNode);
                    return;
                }

                // If no node was clicked, check for an edge
                const clickedEdge = getEdgeAt(x, y);
                if (clickedEdge) {
                    removeEdge(clickedEdge);
                }
            }

            /**
             * Removes a node and all connected edges
             */
            function removeNode(nodeToRemove) {
                nodes = nodes.filter(node => node.id !== nodeToRemove.id);
                // Also remove any edges connected to this node
                edges = edges.filter(edge => edge.from !== nodeToRemove.id && edge.to !== nodeToRemove.id);
            }

            /**
             * Removes a single edge
             */
            function removeEdge(edgeToRemove) {
                // This works because getEdgeAt returns the actual object from the edges array
                edges = edges.filter(edge => edge !== edgeToRemove);
            }

            /**
             * Clears the graph and resets the state
             */
            function clearGraph() {
                nodes = [];
                edges = [];
                currentNodeId = 0;
                edgeStartNode = null;
                pathStartNode = null;
                shortestPath = [];
                setMode('addNode'); // Reset mode
                draw();
            }

            // --- Pathfinding Functions ---

            /**
             * Simple Priority Queue implementation for Dijkstra's
             */
            class PriorityQueue {
                constructor() {
                    this.items = [];
                }
                enqueue(element, priority) {
                    this.items.push({ element, priority });
                    this.items.sort((a, b) => a.priority - b.priority);
                }
                dequeue() {
                    return this.items.shift();
                }
                isEmpty() {
                    return this.items.length === 0;
                }
            }

            /**
             * Calculates Euclidean distance between two points
             */
            function dist(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            /**
             * Helper to add an undirected edge to an adjacency map
             */
            function addTempEdge(map, id1, id2, weight) {
                map.get(id1).push({ id: id2, weight });
                map.get(id2).push({ id: id1, weight });
            }

            /**
             * Helper to remove an undirected edge from an adjacency map
             */
            function removeTempEdge(map, id1, id2) {
                map.set(id1, map.get(id1).filter(edge => edge.id !== id2));
                map.set(id2, map.get(id2).filter(edge => edge.id !== id1));
            }

            /**
             * Finds the closest point on the *entire graph* (any edge) to a given node.
             */
            function findClosestGraphPoint(node) {
                if (edges.length === 0) return null;

                let minDistance = Infinity;
                let bestPoint = null;
                let bestEdge = null;

                for (const edge of edges) {
                    const nodeA = nodes.find(n => n.id === edge.from);
                    const nodeB = nodes.find(n => n.id === edge.to);
                    if (!nodeA || !nodeB) continue;

                    const closestPointOnEdge = getClosestPointOnSegment(node, nodeA, nodeB);
                    const d = dist(node, closestPointOnEdge);

                    if (d < minDistance) {
                        minDistance = d;
                        bestPoint = closestPointOnEdge;
                        bestEdge = edge;
                    }
                }
                return { point: bestPoint, edge: bestEdge, distance: minDistance };
            }

            /**
             * Builds the base adjacency list and coordinate map for Dijkstra's
             */
            function buildWeightedEdgeList() {
                const connectedNodes = new Set();
                const weightedEdges = [];
                
                edges.forEach(edge => {
                    connectedNodes.add(edge.from);
                    connectedNodes.add(edge.to);
                    weightedEdges.push(edge);
                });

                const graphEdges = new Map(); // Adjacency list: nodeId -> [{ id, weight }]
                const nodeCoords = new Map(); // nodeId -> {x, y}

                connectedNodes.forEach(id => {
                    graphEdges.set(id, []);
                    nodeCoords.set(id, nodes.find(n => n.id === id));
                });

                weightedEdges.forEach(edge => {
                    const nodeA = nodeCoords.get(edge.from);
                    const nodeB = nodeCoords.get(edge.to);
                    const weight = dist(nodeA, nodeB);
                    addTempEdge(graphEdges, edge.from, edge.to, weight);
                });

                return { graphEdges, nodeCoords };
            }

            /**
             * Runs Dijkstra's algorithm on the temporary graph
             */
            function dijkstra(graphEdges, nodeCoords, startNodeId, endNodeId) {
                const distances = new Map();
                const previous = new Map();
                const pq = new PriorityQueue();
                
                nodeCoords.forEach((_, id) => {
                    distances.set(id, Infinity);
                    previous.set(id, null);
                });

                distances.set(startNodeId, 0);
                pq.enqueue(startNodeId, 0);

                while (!pq.isEmpty()) {
                    const { element: currentNodeId, priority } = pq.dequeue();

                    if (priority > distances.get(currentNodeId)) {
                        continue;
                    }
                    
                    if (currentNodeId === endNodeId) {
                         break; // Path found
                    }

                    if (!graphEdges.has(currentNodeId)) continue; // Node has no outgoing edges

                    graphEdges.get(currentNodeId).forEach(neighbor => {
                        const newDist = distances.get(currentNodeId) + neighbor.weight;
                        if (newDist < distances.get(neighbor.id)) {
                            distances.set(neighbor.id, newDist);
                            previous.set(neighbor.id, currentNodeId);
                            pq.enqueue(neighbor.id, newDist);
                        }
                    });
                }

                // Reconstruct path
                const path = [];
                let current = endNodeId;
                while (current !== null) {
                    path.unshift(current);
                    if (!previous.has(current)) break; // Path doesn't exist
                    current = previous.get(current);
                }

                return (path[0] === startNodeId) ? path : []; // Return path or empty array
            }
            
            /**
             * Main function to calculate the shortest path
             */
            function calculateShortestPath(startNode, endNode) {
                if (edges.length === 0) {
                    // No graph to route on, just draw a straight line
                    shortestPath = [startNode, endNode];
                    return;
                }

                // 1. Build base graph
                const { graphEdges, nodeCoords } = buildWeightedEdgeList();

                // 2. Find projections
                const startProj = findClosestGraphPoint(startNode);
                const endProj = findClosestGraphPoint(endNode);

                const tempStartNodeId = -1;
                const tempEndNodeId = -2;

                // 3. Handle projections being on the same edge
                if (startProj.edge === endProj.edge) {
                    const { edge } = startProj;
                    const nodeA_id = edge.from;
                    const nodeB_id = edge.to;
                    const nodeA = nodeCoords.get(nodeA_id);
                    const nodeB = nodeCoords.get(nodeB_id);
                    const pStart = startProj.point;
                    const pEnd = endProj.point;

                    // Remove old edge
                    removeTempEdge(graphEdges, nodeA_id, nodeB_id);

                    // Add new temp nodes
                    graphEdges.set(tempStartNodeId, []);
                    graphEdges.set(tempEndNodeId, []);
                    nodeCoords.set(tempStartNodeId, pStart);
                    nodeCoords.set(tempEndNodeId, pEnd);

                    // Add new sub-edges
                    addTempEdge(graphEdges, nodeA_id, tempStartNodeId, dist(nodeA, pStart));
                    addTempEdge(graphEdges, nodeB_id, tempStartNodeId, dist(nodeB, pStart));
                    addTempEdge(graphEdges, nodeA_id, tempEndNodeId, dist(nodeA, pEnd));
                    addTempEdge(graphEdges, nodeB_id, tempEndNodeId, dist(nodeB, pEnd));
                    addTempEdge(graphEdges, tempStartNodeId, tempEndNodeId, dist(pStart, pEnd));

                } else {
                    // 4. Projections on different edges
                    // Handle Start Projection
                    const { edge: startEdge, point: pStart } = startProj;
                    const startA_id = startEdge.from;
                    const startB_id = startEdge.to;
                    removeTempEdge(graphEdges, startA_id, startB_id);
                    graphEdges.set(tempStartNodeId, []);
                    nodeCoords.set(tempStartNodeId, pStart);
                    addTempEdge(graphEdges, startA_id, tempStartNodeId, dist(nodeCoords.get(startA_id), pStart));
                    addTempEdge(graphEdges, startB_id, tempStartNodeId, dist(nodeCoords.get(startB_id), pStart));

                    // Handle End Projection
                    const { edge: endEdge, point: pEnd } = endProj;
                    const endA_id = endEdge.from;
                    const endB_id = endEdge.to;
                    removeTempEdge(graphEdges, endA_id, endB_id);
                    graphEdges.set(tempEndNodeId, []);
                    nodeCoords.set(tempEndNodeId, pEnd);
                    addTempEdge(graphEdges, endA_id, tempEndNodeId, dist(nodeCoords.get(endA_id), pEnd));
                    addTempEdge(graphEdges, endB_id, tempEndNodeId, dist(nodeCoords.get(endB_id), pEnd));
                }

                // 5. Run Dijkstra's
                const pathNodeIds = dijkstra(graphEdges, nodeCoords, tempStartNodeId, tempEndNodeId);
                
                // 6. Convert path IDs to points
                const pathPoints = pathNodeIds.map(id => nodeCoords.get(id));

                // 7. Set final path
                shortestPath = [startNode, ...pathPoints, endNode];
            }

            /**
             * Handles clicks in 'findPath' mode
             */
            function handleFindPath(x, y) {
                const clickedNode = getNodeAt(x, y);
                if (!clickedNode) return; // Must click a node

                if (!pathStartNode) {
                    pathStartNode = clickedNode;
                    instructionText.innerHTML = '<b>Mode:</b> Find Path. Click the end node.';
                } else {
                    if (clickedNode.id === pathStartNode.id) return; // Can't select same node
                    
                    const pathEndNode = clickedNode;
                    instructionText.innerHTML = '<b>Mode:</b> Find Path. Calculating...';

                    // Use a short timeout to allow instruction to render before blocking
                    setTimeout(() => {
                        calculateShortestPath(pathStartNode, pathEndNode);
                        instructionText.innerHTML = `<b>Mode:</b> Find Path. Path shown. Click 'Find Path' to start over.`;
                        draw(); // Redraw with the path
                    }, 10);
                }
            }


            // --- Drawing Functions ---

            /**
             * Main draw function, clears and redraws the entire graph
             */
            function draw() {
                if (!ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawEdges();
                drawNodes();
                drawShortestPath();

                // Highlight the starting node if we're in the middle of adding an edge or path
                if (mode === 'addEdge' && edgeStartNode) {
                    drawNode(edgeStartNode, '#facc15'); // yellow-400
                }
                if (mode === 'findPath' && pathStartNode) {
                    drawNode(pathStartNode, '#facc15'); // yellow-400
}
            }

            /**
             * Draws all nodes
             */
            function drawNodes() {
                nodes.forEach(node => drawNode(node, '#ef4444')); // red-500
            }

            /**
             * Draws a single node
             */
            function drawNode(node, color) {
                // Draw the main circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#1f2937'; // gray-800
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            /**
             * Draws the calculated shortest path
             */
            function drawShortestPath() {
                if (shortestPath.length < 2) return;

                ctx.strokeStyle = '#22c55e'; // green-500
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.setLineDash([10, 10]); // Make it a dashed line

                ctx.beginPath();
                ctx.moveTo(shortestPath[0].x, shortestPath[0].y);
                for (let i = 1; i < shortestPath.length; i++) {
                    ctx.lineTo(shortestPath[i].x, shortestPath[i].y);
                }
                ctx.stroke();
                
                ctx.setLineDash([]); // Reset line dash
            }

            /**
             * Draws all edges
             */
            function drawEdges() {
                ctx.strokeStyle = '#3b82f6'; // blue-500
                ctx.lineWidth = 3;

                edges.forEach(edge => {
                    const nodeFrom = nodes.find(n => n.id === edge.from);
                    const nodeTo = nodes.find(n => n.id === edge.to);

                    if (nodeFrom && nodeTo) {
                        ctx.beginPath();
                        ctx.moveTo(nodeFrom.x, nodeFrom.y);
                        ctx.lineTo(nodeTo.x, nodeTo.y);
                        ctx.stroke();
                    }
                });
            }
        });
    </script>
</body>
</html>



